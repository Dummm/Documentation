\chapter{Tehnologii utilizate}

\section{Linux}
    \subsection{namespace}
        \paragraph{} Un \textit{namespace} înfășoară o resursă globală de sistem printr-o abstractizare care face ca procesele din \textit{namespace} să creadă că au propria lor instanță izolată a resursei globale. Modificările aduse resursei globale sunt vizibile altor procese care sunt membre ale \textit{namespace}-ului, dar sunt invizibile pentru alte procese.\cite{ns:man}
        \paragraph{} În prezent, Linux implementează opt tipuri diferite de \textit{namespace}-uri.

        \subsubsection{Mount namespace}
            \paragraph{} \textit{Mount namespace}-ul (CLONE\_NEWNS, Linux 2.4.19) izolează setul de \textit{mount point}-uri a sistemelor de fișiere văzute de un grup de procese. Astfel, procesele din diferite \textit{mount namespace}-uri pot avea vederi diferite ale ierarhiei sistemului de fișiere. Odată cu adăugarea \textit{mount namespace}-urilor, apelurile de sistem \textit{mount()} și \textit{umount()} au încetat să funcționeze pe un set global de \textit{mount point}-uri vizibile pentru toate procesele din sistem și în schimb au efectuat operațiuni care au afectat doar \textit{mount namespace}-ul asociat procesului de apelare. \cite{ns:lwn}
            \paragraph{} O utilizare a \textit{mount namespace}-urilor este crearea de medii care sunt similare cu închisorile chroot. Cu toate acestea, spre deosebire apelul de sistem \textit{chroot()}, \textit{mount namespace}-urile sunt un instrument mai sigur și mai flexibil pentru această sarcină. Sunt posibile și alte utilizări mai sofisticate ale \textit{mount namespace}-urilor. De exemplu, \textit{mount namespace}-urile separate pot fi configurate într-o relație \textit{master}-\textit{slave}, astfel încât evenimentele de montare să fie propagate automat de la un \textit{namespace} la altul; acest lucru permite, de exemplu, unui hard disk care este montat într-un \textit{namespace} să apară automat în alte \textit{namespace}-uri. \cite{ns:lwn}
            \paragraph{} \textit{Mount namespace}-ul a fost primul tip de \textit{namespace} care a fost implementat pe Linux, apărut în 2002. Acest fapt explică numele destul de generic "NEWNS” (scurt pentru "new namespace”). \cite{ns:lwn}

        \subsubsection{UTS namespace}
            \paragraph{} \textit{UTS namespace}-urile (CLONE\_NEWUTS, Linux 2.6.19) izolează două identificatoare de sistem, \textit{nodename} și \textit{domainname}, returnate de apelul de sistem \textit{uname()}; acestea putănd fi setate folosind apelurile de sistem \textit{sethostname()} și \textit{setdomainname()}. În contextul containerelor, funcția \textit{UTS namespace}-urilor permite fiecărui container să aibă propriul \textit{hostname} și propriul \textit{NIS domain name}. Acest lucru poate fi util pentru scripturile de inițializare și configurare care își adaptează acțiunile pe baza acestor nume. Termenul \textit{UTS} derivă din numele structurii transmise apelului de sistem \textit{uname()}: struct utsname. Numele acestei structuri provine, la rândul său, de la \textit{UNIX Time-sharing System}. \cite{ns:lwn}

        \subsubsection{IPC namespace}
            \paragraph{} \textit{IPC namespace}-urile (CLONE\_NEWIPC, Linux 2.6.19) izolează anumite resurse de comunicare între procese (\textit{IPC}; \textit{interprocess communication}), și anume, obiecte \textit{IPC System V} și (de la Linux 2.6.30) cozi \textit{POSIX} de mesaje. Caracteristica comună a acestor mecanisme IPC este că obiectele IPC sunt identificate prin alte mecanisme decât \textit{pathname}-urile sistemelor de fișiere. Fiecare \textit{IPC namespace} are propriul set de identificatori \textit{IPC System V} și propriul sistem de fișiere pentru cozile \textit{POSIX} de mesaje. \cite{ns:lwn}

        \subsubsection{PID namespace}
            \paragraph{} \textit{PID namespace}-urile (CLONE\_NEWPID, Linux 2.6.24) izolează spațiul numerelor de identificare ale proceselor. Cu alte cuvinte, procesele din \textit{PID namespace}-uri diferite pot avea același PID. Unul dintre avantajele principale ale \textit{PID namespace}-urilor este faptul că containerele pot fi migrate între gazde păstrând aceleași PID-uri pentru procesele din interiorul containerului. \textit{PID namespace}-urile permit, de asemenea, fiecărui container să aibă propriul său \textit{init} (PID 1), "strămoșul tuturor proceselor” care gestionează diverse activități de inițializare a sistemului și reface procesele copil orfane atunci când se termină. \cite{ns:lwn}
            \paragraph{} Din punctul de vedere al unei anumite instanțe de \textit{PID namespace}, un proces are două PID-uri: PID-ul din \textit{namespace} și PID-ul în afara \textit{namespace}-ului, din sistemul gazdă. Un proces poate vedea (de exemplu, să vizualizeze prin \textit{/proc/PID} sau să trimită semnale cu \textit{kill()}) doar procesele conținute în \textit{PID namespace}-ul său și \textit{namespace}-urile aflate sub acel \textit{PID namespace}. \cite{ns:lwn}

        \subsubsection{Network namespace}
            \paragraph{} \textit{Network namespace}-urile (CLONE\_NEWNET, începute în Linux 2.4.19 2.6.24 și completate în mare parte în aproximativ Linux 2.6.29) asigură izolarea resurselor de sistem asociate cu rețelelor. Astfel, fiecare \textit{network namespace} are propriile dispozitive de rețea, adrese IP, tabele de rutare IP, director \textit{/proc/net} și numere de port. \cite{ns:lwn}
            \paragraph{} \textit{Network namespace}-urile din rețea fac ca containerele să fie utile dintr-o perspectivă de rețea: fiecare container poate avea propriul dispozitiv de rețea (virtual) și propriile aplicații care se leagă la al porturile  \textit{namespace}-ului; reguli de rutare adecvate în sistemul gazdă pot direcționa pachetele de rețea către dispozitivul de rețea asociat unui anumit container. Astfel, de exemplu, este posibil să existe mai multe servere web containerizate pe același sistem gazdă, fiecare server fiind legat la portul 80 în \textit{namespace}. \cite{ns:lwn}

        \subsubsection{User namespace}
            \paragraph{} \textit{User namespace}-urile (CLONE\_NEWUSER, începute în Linux 2.6.23 și completate în Linux 3.8) izoleaza spațiile numerelor de identificare ale utilizatorului și grupului. Cu alte cuvinte, ID-urile de utilizator și de grup ale unui proces pot fi diferite în interiorul și în afara unui \textit{user namespace}. Cel mai interesant caz este faptul că un proces poate avea un ID de utilizator normal neprivilejat în afara unui \textit{user namespace}, având în același timp un ID de utilizator 0 în interiorul \textit{namespace}-ului. Acest lucru înseamnă că procesul are privilegii root complete pentru operațiunile din \textit{user namespace}, dar nu este privilegiat pentru operațiuni în afara \textit{namespace}-ului. \cite{ns:lwn}

        \subsubsection{Cgroup namespace}
            \paragraph{} \textit{Cgroup namespace}-urile (CLONE\_NEWCGROUP, Linux 4.6) izoleaza vizualizarea cgrupurilor unui proces, care pot fi accesate prin \textit{/proc/[pid]/cgroup} și \textit{/proc/[pid]/mountinfo}. \cite{ns:cgroup}
            \paragraph{} Fiecare \textit{namespace} are propriul set de directoare cgroup rădăcină. Aceste directoare rădăcină sunt punctele de bază pentru locațiile relative afișate în din fişierul \textit{/proc/[pid]/cgroup}. Când un proces creează un nou \textit{cgroup namespace} folosind \textit{clone(2)} sau \textit{unshare(2)} cu \textit{flag}-ul CLONE\_NEWCGROUP, directoarele sale cgroup curente devin directoarele cgroup rădăcină ale noului \textit{namespace}. \cite{ns:cgroup}

        \subsubsection{Time namespace}
            \paragraph{} \textit{Time namespace}-urile izoleaza valorile a două ceasuri de sistem: CLOCK\_MONOTONIC și CLOCK\_BOOTTIME.\cite{ns:time}
            \paragraph{} Procesele dintr-un \textit{time namespace} împărtășesc valorile pentru aceste ceasuri. Acest lucru afectează diferite API-uri care măsoară folosind aceste ceasuri, inclusiv: \textit{ceas\_gettime (2)}, \textit{ceas\_nanosleep(2)}, \textit{nanosleep (2)}, \textit{timer\_settime (2)}, \textit{timerfd\_settime (2)} și \textit{/proc/uptime}. \cite{ns:time}
            \paragraph{} În prezent, singura modalitate de a crea un \textit{time namespace} apelând \textit{unshare (2)} cu \textit{flag}-ul CLONE\_NEWTIME. Acest apel creează un nou \textit{time namespace}, dar nu plasează procesul de apelare în noul \textit{namespace}. În schimb, copiii ulterior creați ai procesului de apelare sunt plasați în noul \textit{namespace}. Aceasta permite compensări de ceas pentru ca noul \textit{namespace} să fie setat înainte ca primul proces să fie plasat în \textit{namespace}. Legătura simbolică \textit{/proc/[pid]/ns/time\_for\_children} arată \textit{time namespace}-ul în care copiii procesului for fi creați. \cite{ns:time}

    \subsection{cgroup}
    \subsection{overlayFS}
\section{rust}

\chapter{Tehnologii utilizate}

\section{Linux}
    \subsection{namespace}
        \paragraph{} Un \textit{namespace} înfășoară o resursă globală de sistem printr-o abstractizare care face ca procesele din \textit{namespace} să creadă că au propria lor instanță izolată a resursei globale. Modificările aduse resursei globale sunt vizibile altor procese care sunt membre ale \textit{namespace}-ului, dar sunt invizibile pentru alte procese.\cite{ns:man}
        \paragraph{} În prezent, Linux implementează opt tipuri diferite de \textit{namespace}-uri.

        \subsubsection{Mount namespace}
            \paragraph{} \textit{Mount namespace}-ul (CLONE\_NEWNS, Linux 2.4.19) izolează setul de \textit{mount point}-uri a sistemelor de fișiere văzute de un grup de procese. Astfel, procesele din diferite \textit{mount namespace}-uri pot avea vederi diferite ale ierarhiei sistemului de fișiere. Odată cu adăugarea \textit{mount namespace}-urilor, apelurile de sistem \textit{mount()} și \textit{umount()} au încetat să funcționeze pe un set global de \textit{mount point}-uri vizibile pentru toate procesele din sistem și în schimb au efectuat operațiuni care au afectat doar \textit{mount namespace}-ul asociat procesului de apelare. \cite{ns:lwn}
            \paragraph{} O utilizare a \textit{mount namespace}-urilor este crearea de medii care sunt similare cu închisorile chroot. Cu toate acestea, spre deosebire apelul de sistem \textit{chroot()}, \textit{mount namespace}-urile sunt un instrument mai sigur și mai flexibil pentru această sarcină. Sunt posibile și alte utilizări mai sofisticate ale \textit{mount namespace}-urilor. De exemplu, \textit{mount namespace}-urile separate pot fi configurate într-o relație \textit{master}-\textit{slave}, astfel încât evenimentele de montare să fie propagate automat de la un \textit{namespace} la altul; acest lucru permite, de exemplu, unui hard disk care este montat într-un \textit{namespace} să apară automat în alte \textit{namespace}-uri. \cite{ns:lwn}
            \paragraph{} \textit{Mount namespace}-ul a fost primul tip de \textit{namespace} care a fost implementat pe Linux, apărut în 2002. Acest fapt explică numele destul de generic "NEWNS" (scurt pentru "new namespace"). \cite{ns:lwn}

        \subsubsection{UTS namespace}
            \paragraph{} \textit{UTS namespace}-urile (CLONE\_NEWUTS, Linux 2.6.19) izolează două identificatoare de sistem, \textit{nodename} și \textit{domainname}, returnate de apelul de sistem \textit{uname()}; acestea putănd fi setate folosind apelurile de sistem \textit{sethostname()} și \textit{setdomainname()}. În contextul containerelor, funcția \textit{UTS namespace}-urilor permite fiecărui container să aibă propriul \textit{hostname} și propriul \textit{NIS domain name}. Acest lucru poate fi util pentru scripturile de inițializare și configurare care își adaptează acțiunile pe baza acestor nume. Termenul \textit{UTS} derivă din numele structurii transmise apelului de sistem \textit{uname()}: struct utsname. Numele acestei structuri provine, la rândul său, de la \textit{UNIX Time-sharing System}. \cite{ns:lwn}

        \subsubsection{IPC namespace}
            \paragraph{} \textit{IPC namespace}-urile (CLONE\_NEWIPC, Linux 2.6.19) izolează anumite resurse de comunicare între procese (\textit{IPC}; \textit{interprocess communication}), și anume, obiecte \textit{IPC System V} și (de la Linux 2.6.30) cozi \textit{POSIX} de mesaje. Caracteristica comună a acestor mecanisme IPC este că obiectele IPC sunt identificate prin alte mecanisme decât \textit{pathname}-urile sistemelor de fișiere. Fiecare \textit{IPC namespace} are propriul set de identificatori \textit{IPC System V} și propriul sistem de fișiere pentru cozile \textit{POSIX} de mesaje. \cite{ns:lwn}

        \subsubsection{PID namespace}
            \paragraph{} \textit{PID namespace}-urile (CLONE\_NEWPID, Linux 2.6.24) izolează spațiul numerelor de identificare ale proceselor. Cu alte cuvinte, procesele din \textit{PID namespace}-uri diferite pot avea același PID. Unul dintre avantajele principale ale \textit{PID namespace}-urilor este faptul că containerele pot fi migrate între gazde păstrând aceleași PID-uri pentru procesele din interiorul containerului. \textit{PID namespace}-urile permit, de asemenea, fiecărui container să aibă propriul său \textit{init} (PID 1), "strămoșul tuturor proceselor" care gestionează diverse activități de inițializare a sistemului și reface procesele copil orfane atunci când se termină. \cite{ns:lwn}
            \paragraph{} Din punctul de vedere al unei anumite instanțe de \textit{PID namespace}, un proces are două PID-uri: PID-ul din \textit{namespace} și PID-ul în afara \textit{namespace}-ului, din sistemul gazdă. Un proces poate vedea (de exemplu, să vizualizeze prin \textit{/proc/PID} sau să trimită semnale cu \textit{kill()}) doar procesele conținute în \textit{PID namespace}-ul său și \textit{namespace}-urile aflate sub acel \textit{PID namespace}. \cite{ns:lwn}

        \subsubsection{Network namespace}
            \paragraph{} \textit{Network namespace}-urile (CLONE\_NEWNET, începute în Linux 2.4.19 2.6.24 și completate în mare parte în aproximativ Linux 2.6.29) asigură izolarea resurselor de sistem asociate cu rețelelor. Astfel, fiecare \textit{network namespace} are propriile dispozitive de rețea, adrese IP, tabele de rutare IP, director \textit{/proc/net} și numere de port. \cite{ns:lwn}
            \paragraph{} \textit{Network namespace}-urile din rețea fac ca containerele să fie utile dintr-o perspectivă de rețea: fiecare container poate avea propriul dispozitiv de rețea (virtual) și propriile aplicații care se leagă la al porturile  \textit{namespace}-ului; reguli de rutare adecvate în sistemul gazdă pot direcționa pachetele de rețea către dispozitivul de rețea asociat unui anumit container. Astfel, de exemplu, este posibil să existe mai multe servere web containerizate pe același sistem gazdă, fiecare server fiind legat la portul 80 în \textit{namespace}. \cite{ns:lwn}

        \subsubsection{User namespace}
            \paragraph{} \textit{User namespace}-urile (CLONE\_NEWUSER, începute în Linux 2.6.23 și completate în Linux 3.8) izoleaza spațiile numerelor de identificare ale utilizatorului și grupului. Cu alte cuvinte, ID-urile de utilizator și de grup ale unui proces pot fi diferite în interiorul și în afara unui \textit{user namespace}. Cel mai interesant caz este faptul că un proces poate avea un ID de utilizator normal neprivilejat în afara unui \textit{user namespace}, având în același timp un ID de utilizator 0 în interiorul \textit{namespace}-ului. Acest lucru înseamnă că procesul are privilegii root complete pentru operațiunile din \textit{user namespace}, dar nu este privilegiat pentru operațiuni în afara \textit{namespace}-ului. \cite{ns:lwn}

        \subsubsection{Cgroup namespace}
            \paragraph{} \textit{Cgroup namespace}-urile (CLONE\_NEWCGROUP, Linux 4.6) izoleaza vizualizarea cgrupurilor unui proces, care pot fi accesate prin \textit{/proc/[pid]/cgroup} și \\ \textit{/proc/[pid]/mountinfo}. \cite{ns:cgroup}
            \paragraph{} Fiecare \textit{namespace} are propriul set de directoare cgroup rădăcină. Aceste directoare rădăcină sunt punctele de bază pentru locațiile relative afișate în din fişierul \textit{/proc/[pid]/cgroup}. Când un proces creează un nou \textit{cgroup namespace} folosind \textit{clone(2)} sau \textit{unshare(2)} cu \textit{flag}-ul CLONE\_NEWCGROUP, directoarele sale cgroup curente devin directoarele cgroup rădăcină ale noului \textit{namespace}. \cite{ns:cgroup}

        \subsubsection{Time namespace}
            \paragraph{} \textit{Time namespace}-urile izoleaza valorile a două ceasuri de sistem: CLOCK\_MONO\-TONIC și CLOCK\_BOOTTIME.\cite{ns:time}
            \paragraph{} Procesele dintr-un \textit{time namespace} împărtășesc valorile pentru aceste ceasuri, lucru care afectează diferite API-uri care măsoară folosind aceste ceasuri, inclusiv: \\ \textit{clock\_gettime (2)}, \textit{clock\_nanosleep(2)}, \textit{nanosleep (2)}, \textit{timer\_settime (2)}, \\ \textit{timerfd\_settime (2)} și \textit{/proc/uptime}. \cite{ns:time}
            \paragraph{} În prezent, singura modalitate de a crea un \textit{time namespace} apelând \textit{unshare (2)} cu \textit{flag}-ul CLONE\_NEWTIME. Acest apel creează un nou \textit{time namespace}, dar nu plasează procesul de apelare în noul \textit{namespace}. În schimb, copiii ulterior creați ai procesului de apelare sunt plasați în noul \textit{namespace}. Aceasta permite compensări de ceas pentru ca noul \textit{namespace} să fie setat înainte ca primul proces să fie plasat în \textit{namespace}. Legătura simbolică \textit{/proc/[pid]/ns/time\_for\_children} arată \textit{time namespace}-ul în care copiii procesului for fi creați. \cite{ns:time}

    \subsection{cgroup (Control group)}
        \paragraph{} Grupur de control, denumit de obicei cgroup, este o caracteristică a \textit{kernelului} Linux care permite organizarea ierarhică a proceselor în grupuri, și limitarea și monitorizarea diferitelor tipuri de resurse care pot fi utilizate de acestea. Interfața cgroup este furnizată prin intermediul unui pseudo-sistem de fișiere numit \textit{cgroupfs}. Gruparea este implementată în codul nucleului, în timp ce monitorizarea resurselor și limitele sunt implementate într-un set de subsisteme pentru fiecare tip de resursă (memorie, procesor, etc.). \cite{cg:man}
        \paragraph{} Un subsistem este o componentă a \textit{kernelului} care modifică comportamentul proceselor dintr-un cgroup. Au fost implementate diferite subsisteme, care fac posibilă realizarea unor lucruri precum limitarea timpului de procesor și a memoriei disponibile pentru un cgroup, contabilizarea timpului de procesor folosit de un cgroup și înghețarea și reluarea execuției unor procese dintr-un cgroup. Subsistemele sunt uneori cunoscute și sub denumirea de \textit{controllere} de resurse. \cite{cg:man}
        \paragraph{} Cgrupurile pentru un \textit{controller} sunt aranjate într-o ierarhie. Acestă ierarhie este definită prin crearea, eliminarea și redenumirea subdirectoarelor din sistemul de fișiere cgroup. La fiecare nivel al ierarhiei, atributele (de exemplu, limitele) pot fi definite. Controlul sau limitele oferite de cgrupuri au, în general, efect în întreaga sub-ierarhie de sub cgroupul în care atributele sunt definite. Astfel, de exemplu, limitele plasate pe a cgroup la un nivel superior în ierarhie nu pot fi depășite cu cgrupuri descendente. \cite{cg:man}

    \subsection{overlayFS}
        \paragraph{} Sistemele de fișiere Union sunt o soluție care permite combinarea virtuală a mai multor directoare, păstrând conținutul lor real separat. Sistemul de fișiere Overlay (OverlayFS) este un exemplu dintre acestea, deși este mai mult un mecanism de montare decât un sistem de fișiere. \cite{ofs:artic}
        \paragraph{} Adăugat în kernelul Linux în versiunea 3.18, OverlayFS permite suprapunerea conți\-nutului (atât fișierele, cât și directoarele) unui director peste altul. Directoarele sursă pot fi pe diferite volume și pot fi chiar sisteme de fișiere diferite, ceea ce creează un mecanism care permite modificarea temporară a fișierelor și directoarelor \textit{read-only}. \cite{ofs:artic}
        \paragraph{} Un sistem de fișiere \textit{overlayFS} combină două sisteme de fișiere - un sistem de fișiere "superior"(\textit{upper}) și un sistem de fișiere "inferior"(\textit{lower}). Când un nume există în ambele sisteme de fișiere, obiectul din sistemul de fișiere "superior" este vizibil în timp ce obiectul din sistemul de fișiere "inferior" este ascuns sau, în cazul directoarelor, combinat cu obiectul "superior". \cite{ofs:kernel}

\section{rust}
\paragraph{} Rust este un limbaj de programare multi-paradigmă axat pe performanță și siguran\-ță, în special concurgență sigură. Rust este similar sintactic cu C++, dar asigură securitatea memoriei fără a folosi \textit{garbage collection}. \cite{wiki:rust}

    \subsubsection{Securitatea memoriei}
        \paragraph{} Rust este proiectat să fie \textit{memory safe} și, prin urmare, nu permite pointeri nuli, \textit{dangling pointeri} sau \textit{data race}-uri în cod sigur. Pentru a reproduce funcția pointerilor din alte limbi, de a fi valizi sau NULL, cum ar fi în listele înlănțuite sau în arborii binari, biblioteca de bază Rust oferă un tip de dată opțiune, care poate fi utilizat pentru a testa dacă un pointer are o valoare (\textit{Some}) sau nu (\textit{None}). De asemenea, Rust introduce sintaxa suplimentară pentru a gestiona valabilitatea (\textit{lifetime}), iar compilatorul verifică acest lucru prin intermediul unui \textit{borrow checker}. Codul nesigur care poate subverti unele dintre aceste restricții poate fi scris folosind cuvântul cheie \textit{unsafe}. \cite{wiki:rust}

    \subsubsection{Gestionarea memoriei}
        \paragraph{} Rust nu folosește un sistem automat de \textit{garbage collection} precum cele utilizate în Go, Java sau .NET Framework și nu utilizează \textit{Automatic Reference Counting} folosit în limbaje precum Swift și Objective-C. În schimb, memoria și alte resurse sunt gestionate prin convenția "achiziția resurselor este inițializarea" (RAII; resource acquisition is initialization), cu \textit{reference counting} opțional. \cite{wiki:rust}
        \paragraph{} Siguranța utilizării \textit{ponterilor} este verificată la compilare de către \textit{borrow checker}, prevenind \textit{dangling pointerii} și alte forme de comportament nedefinit. \cite{wiki:rust}

    \subsubsection{Tipuri și polimorfism}
        \paragraph{} Sistemul de tip acceptă un mecanism similar claselor, numit "trăsătură"(\textit{trait}), inspirat direct de limbajul Haskell. Aceasta este o facilitate pentru polimorfismul ad-hoc, obținută prin adăugarea de constrângeri la declarațiile de tip variabil. \cite{wiki:rust}
        \paragraph{} Rust folosește inferența de tip, pentru variabilele declarate cu cuvântul cheie \textit{let}. Astfel de variabile nu necesită o valoare alocată inițial pentru a determina tipul acestora. O eroare de compilare rezultă daca o ramură a codului nu reușește să atribuie o valoare variabilei. Variabilele alocate de mai multe ori, mutabile, trebuie marcate cu cuvântul cheie \textit{mut}. \cite{wiki:rust}
        \paragraph{} Sistemul de obiecte din Rust se bazează în jurul implementărilor, trăsăturilor și tipurilor structurate. Implementările îndeplinesc un rol similar cu cel al claselor din alte limbi și sunt definite cu ajutorul cuvântului cheie \textit{impl}. Moștenirea și polimorfismul sunt asigurate de trăsături; ele permit definirea metodelor și amestecarea lor în implementări. Tipurile structurate sunt utilizate pentru a defini câmpurile. Implementările și trăsăturile nu pot defini singure câmpurile și numai trăsăturile pot fi folosite pentru moștenire. Un beneficiu al acestor trasaturi este că se previne problema diamantului, ca în C++. \cite{wiki:rust}